---
layout: post
title: 'Promise的实现'
date: 2019-05-01
author: jiangbei
tags: es6
---

## 规范

* <font color="#2ca6cb">Promise 是一个 thenable 对象, 也就是说 Promise 有一个 .then() 方法</font>
* <font color="#2ca6cb">一个 pending 状态的 Promise 可以进入 fulfilled 和 rejected 状态</font>
* <font color="#2ca6cb">promise 一旦进入 fulfilled 或 rejected 状态, 不可再改变其状态</font>
* <font color="#2ca6cb">一旦 promise 改变了其状态, 它必须有一个值(这个值也可能是 undefined)</font>

### 第一版Promise

* 可以保存回调方法

```javascript

var PromiseAsyncFn = function(){
	var fulfillCallback;
	var rejectCallback;
	setTimeout(()=>{
		const randomNumber = Math.random()
		if(randomNumber>0.5){
			fulfillCallback(randomNumber)
		}else{
			rejectCallback(randomNumber)
		}
	})
	return {
		then:function(_fulfillCallback,_rejectCallback){
			fulfillCallback = _fulfillCallback;
			rejectCallback = _rejectCallback;
		}
	}
}


```


我们的思路是，在then()方法中保存，将fulfill和reject保存下来，然后在异步方法中调用。根据**event-loop**原理，
当我们在异步函数中调用的时候，fulfillCallback和rejectCallback两个回调函数一定是赋过值的



### 第二版Promise

* 我们把异步代码和Promise区分开

```javascript

var promiseAsyncFn = function(){
	var fulfillCallback;
	var rejectCallback;
	
	return{
		fulfill:function(value){
			if(fulfillCallback && typeof fulfillCallback === 'function'){
				fulfillCallback(value)
			}
		},
		reject:function(err){
			if(rejectCallback && typeof rejectCallback === 'function'){
				rejectCallback(err)
			}
		},
		then:function(_fulfillCallback,_rejectCallback){
			fulfillCallback = _fulfillCallback
			rejectCallback = _rejectCallback
		}
	}
}

var ownPromise = function(asyncCallback){
	var promise = promiseAsyncFn();
	asyncCallback(promise.fulfill, promise.reject)
	return promise
}

ownPromise((resolve,reject)=>{
	setTimeout(()=>{
		var randomNumber = Math.random();
		if(randomNumber>0.5){
			resolve(randomNumber)
		}else{
			reject(randomNumber)
		}
	})
}).then(res=>{
	console.log(res)
},err=>{
	console.log(err)
})


```

我们定义了一个方法<font color="#f92672">ownPromise()</font>用来创建Promise，
并在<font color="#f92672">promiseAsyncFn()</font>方法中暴露出<font color="#f92672">fulfill</font>和<font color="#f92672">reject</font>接口方便异步代码调用

** 问题：  
这里有一个问题，我们在调用 ownPromise()后得到了 promise 实例，此时我们可以直接调用 fulfill()，
reject()这两个方法，而理论上我们应该只应暴露 promise 的then()方法。所以我们利用闭包将这两个方法隐藏


```javascript

var promiseAsyncFn = function(){
	var fulfillCallback;
	var rejectCallback;
	
	return{
		fulfill:function(value){
			if(fulfillCallback && typeof fulfillCallback === 'function'){
				fulfillCallback(value)
			}
		},
		reject:function(err){
			if(rejectCallback && typeof rejectCallback === 'function'){
				rejectCallback(err)
			}
		},
		promise:{
			then:function(_fulfillCallback,_rejectCallback){
				fulfillCallback = _fulfillCallback
				rejectCallback = _rejectCallback
			}
		}
	}
}

var ownPromise = function(asyncCallback){
	var defer = promiseAsyncFn();
	asyncCallback(defer.fulfill, defer.reject)
	return defer.promise
}


```


### 第三版

** 支持状态管理

```javascript

const PENDING = Symbol('pending');
const FULFILLED = Symbol('fulfilled');
const REJECTED = Symbol('rejected');

const promiseAsyncFn = function(){
	let status = PENDING;
	let fulfillCallback;
	let rejectCallback;
	
	return{
		fulfill: function(value){
			if(status !== PENDING) return;
			if(fulfillCallback && typeof fulfillCallback === 'function'){
				fulfillCallback(value)
				status = FULFILLED
			}
		},
		reject: function(err){
			if(status !== PENDING) return;
			if(rejectCallback && typeof rejectCallback === 'function'){
				rejectCallback(err)
				status = REJECTED
			}
		},
		promise:{
			then: function(_fulfillCallback,_rejectCallback){
				fulfillCallback = _fulfillCallback
				rejectCallback = _rejectCallback
			}
		}
	}
}

```

为了判断Promise的状态，我们在fulfill和reject方法里面判断了状态status，
如果不是pengding状态则直接return<font color="#f92672">(因为Promise状态只能改变一次)</font>

**问题：**  
** Promise的值没有被保存下来，如果Promise在异步调用完成之后才被调用.then()方法，则我们无法把异步调用结果传给回调函数，因此我们需要加一个value字段


### 第四版 Promise: 保存异步调用的结果

** 加入 value 字段，用于保存 Promise 的执行结果。

```javascript

const promiseAsyncFn = function(){
	let status = PENDING;
	let fulfillCallback;
	let rejectCallback;
	let value;
	
	return{
		fulfill: function(_value){
			if(status !== PENDING) return;
			value = _value
			status = FULFILLED
			if(fulfillCallback && typeof fulfillCallback === 'function'){
				fulfillCallback(value)
			}
		},
		reject: function(err){
			if(status !== PENDING) return;
			value = err
			status = REJECTED
			if(rejectCallback && typeof rejectCallback === 'function'){
				rejectCallback(err)
			}
		},
		promise:{
			then: function(_fulfillCallback,_rejectCallback){
				fulfillCallback = _fulfillCallback
				rejectCallback = _rejectCallback
			}
		}
	}
}


```

**问题:**  
此时我们发现：如果一个Promise已经是fulfill或者reject状态，我们再调用then()方法时，传入的回调函数永远不会执行。因此我们需要在then()方法中判断

```javascript

const promiseAsyncFn = function(){
	let status = PENDING;
	let fulfillCallback;
	let rejectCallback;
	let value;
	
	return{
		fulfill: function(_value){
			if(status !== PENDING) return;
			value = _value
			status = FULFILLED
			if(fulfillCallback && typeof fulfillCallback === 'function'){
				fulfillCallback(value)
			}
		},
		reject: function(err){
			if(status !== PENDING) return;
			value = err
			status = REJECTED
			if(rejectCallback && typeof rejectCallback === 'function'){
				rejectCallback(err)
			}
		},
		promise:{
			then: function(_fulfillCallback,_rejectCallback){
				if(status === FULFILLED){
					_fulfillCallback(value)
					return
				}
				if(status === REJECTED){
					_rejectCallback(value)
					return
				}
				fulfillCallback = _fulfillCallback
				rejectCallback = _rejectCallback
			}
		}
	}
}

//test

const pro = ownPromise((resolve, reject) => {
		var randomNumber = Math.random();
		if (randomNumber > 0.5) {
			resolve(randomNumber)
		} else {
			reject(randomNumber)
		}
	})

	setTimeout(() => {
		pro.then(res => {
			console.log(res)
		}, err => {
			console.log(err)
		})
	}, 100)

```


### 第五版

* 支持链式调用
* 为了支持链式调用，.then() 方法的返回值必须是用 thenable (根据 Promise/A+ 规范, .then() 方法的返回值需要是一个新的 Promise)
* 为此我们加入一个工具方法 makeThenable()。如果传入的 value 本身就有 then()方法，则直接返回 value。否则返回一个有 then()方法的对象。 在该对象的 then()方法中，我们根据 promise 的状态，调用不同的回调方法生成新的 value。


```javascript

function makeThenable(value， status){
  if(value && typeof value.then === 'function'){
    return value
  }
  if(status === FULFILLED){
    return {
      then: function(fulfillCallback, rejectCallback){
        return makeThenable(fulfillCallback(value), FULFILLED)
      }
    }
  }
  if(status === REJECTED) {
    return {
      then: function(fulfillCallback, rejectCallback){
        return makeThenable(rejectCallback(value), FULFILLED)
      }
    }
  }
}

```

有了以上的 makeThenable()方法，我们可以在 promise 的fulfill()，reject()回将 value 设置为 thenable:

```javascript

var promiseAsyncFunc = function() {
  var status = PENDING
  var fulfillCallback
  var rejectCallback
  var value

  return {
    fulfill: function(_value) {
      if (status !== PENDING) return
      value = makeThenable(_value, FULFILLED) // 保证当前promise的value为 thenable
      status = FULFILLED
      if (typeof fulfillCallback === 'function') {
        value.then(fulfillCallback)
      }
    },
    reject(error) {
      if (status !== PENDING) return
      value = makeThenable(error, REJECTED) 、、  // 保证当前value为 thenable
      status = REJECTED
      if (typeof rejectCallback === 'function') {
        value.then(null, rejectCallback)
      }
    },
    promise: {
      then: function(){}
    }
  }
}

```

接下来让我们看 then()方法。为了返回一个新的 promise，我们首先得创建一个新的 promise。其次当前 promise 在fulfill() 或 reject()时，应该调用新的 promise 的fullfill() 或 reject()方法。所以我们在将 fulfullCallback和rejectCallback赋值给当前 promise 时，将其包装一下。代码如下：

```javascript

promise: {
  then: function(_fulfillCallback, _rejectCallback) {
    let newPromiseAsyncFunc = promiseAsyncFunc()
    let fulfillFunc = function(value) {
      newPromiseAsyncFunc.fulfill(_fulfillCallback(value))
    }
    let rejectFunc = function(err) {
      newPromiseAsyncFunc.fulfill(_rejectCallback(err))
    }
    if (status === PENDING) {
      fulfillCallback = fulfillFunc
      rejectCallback = rejectFunc
    } else {
      value.then(fulfillFunc, rejectFunc)
    }
    return newPromiseAsyncFunc.promise
  }
}


```

**测试一下**

```javascript

const PENDING = Symbol('pending')
const FULFILLED = Symbol('fulfilled')
const REJECTED = Symbol('rejected')

function makeThenable(value, status) {
  if (value && typeof value.then === 'function') {
    return value
  }
  if (status === FULFILLED) {
    return {
      then: function(fulfillCallback, rejectCallback) {
        return makeThenable(fulfillCallback(value), FULFILLED)
      }
    }
  }
  if (status === REJECTED) {
    return {
      then: function(fulfillCallback, rejectCallback) {
        return makeThenable(rejectCallback(value), FULFILLED)
      }
    }
  }
}

// Promise 形式的异步方法定义
var promiseAsyncFunc = function() {
  var status = PENDING
  var fulfillCallback
  var rejectCallback
  var value

  return {
    fulfill: function(_value) {
      if (status !== PENDING) return
      value = makeThenable(_value, FULFILLED)
      status = FULFILLED
      if (typeof fulfillCallback === 'function') {
        value.then(fulfillCallback)
      }
    },
    reject(error) {
      if (status !== PENDING) return
      value = makeThenable(error, REJECTED)
      status = REJECTED
      if (typeof rejectCallback === 'function') {
        value.then(null, rejectCallback)
      }
    },
    promise: {
      then: function(_fulfillCallback, _rejectCallback) {
        let newPromiseAsyncFunc = promiseAsyncFunc()
        let fulfillFunc = function(value) {
          newPromiseAsyncFunc.fulfill(_fulfillCallback(value))
        }
        let rejectFunc = function(err) {
          newPromiseAsyncFunc.fulfill(_rejectCallback(err))
        }
        if (status === PENDING) {
          fulfillCallback = fulfillFunc
          rejectCallback = rejectFunc
        } else {
          value.then(fulfillFunc, rejectFunc)
        }
        return newPromiseAsyncFunc.promise
      }
    }
  }
}

let ownPromise = function(asyncCall) {
  let defer = promiseAsyncFunc()
  asyncCall(defer.fulfill, defer.reject)
  return defer.promise
}

let testChainedPromise = ownPromise(function(fulfill, reject) {
  setTimeout(() => {
    var randomNumber = Math.random()
    if (randomNumber > 0.5) fulfill(randomNumber)
    else reject(randomNumber)
  }, 1000)
})
  .then(
    data => {
      console.log(data)
      return 'return value in then1 fulfill'
    },
    err => {
      console.log(err)
      return 'return value in then1 reject'
    }
  )
  .then(
    data => {
      console.log(data)
      return 'return value in then2 fulfill'
    },
    err => {
      console.log(err)
      return 'return value in then2 reject'
    }
  )
  .then(
    data => {
      console.log(data)
    },
    err => {
      console.log(err)
    }
  )

/**
console output:

0.9931984611850693
return value in then1 fulfill
return value in then2 fulfill
*/


```

### 第六版 Promise: Error handling

**这里我们只对异步调用和fulfill 回调中抛出的 error 进行处理**

* 首先是异步调用部分,我们将其 try catch 起来，在发生异常时调用 reject 方法，并将异常作为参数传入。

```javascript

let ownPromise = function(asyncCall) {
  let defer = promiseAsyncFunc()
  try {
    asyncCall(defer.fulfill, defer.reject)
  } catch (e) {
    defer.reject(e)
  }
  return defer.promise
}

```

* 然后是 fulfill 中可能出现的异常。我们对fulfillCallback(value)可能出现的异常进行捕获，并将异常传递给rejectCallback。

```javascript

function makeThenable(value, status) {
  if (value && typeof value.then === 'function') {
    return value
  }
  if (status === FULFILLED) {
    return {
      then: function(fulfillCallback, rejectCallback) {
        try {
          let newValue = fulfillCallback(value)
          return makeThenable(newValue, FULFILLED)
        } catch (e) {
          return makeThenable(rejectCallback(e), FULFILLED)
        }
      }
    }
  }
  if (status === REJECTED) {
    return {
      then: function(fulfillCallback, rejectCallback) {
        return makeThenable(rejectCallback(value), FULFILLED)
      }
    }
  }
}

```

**最后：我们对完整代码进行测试**

```javascript

const PENDING = Symbol('pending')
const FULFILLED = Symbol('fulfilled')
const REJECTED = Symbol('rejected')

function makeThenable(value, status) {
  if (value && typeof value.then === 'function') {
    return value
  }
  if (status === FULFILLED) {
    return {
      then: function(fulfillCallback, rejectCallback) {
        try {
          let newValue = fulfillCallback(value)
          return makeThenable(newValue, FULFILLED)
        } catch (e) {
          return makeThenable(rejectCallback(e), FULFILLED)
        }
      }
    }
  }
  if (status === REJECTED) {
    return {
      then: function(fulfillCallback, rejectCallback) {
        return makeThenable(rejectCallback(value), FULFILLED)
      }
    }
  }
}

// Promise 形式的异步方法定义
var promiseAsyncFunc = function() {
  var status = PENDING
  var fulfillCallback
  var rejectCallback
  var value

  return {
    fulfill: function(_value) {
      if (status !== PENDING) return
      value = makeThenable(_value, FULFILLED)
      status = FULFILLED
      if (typeof fulfillCallback === 'function') {
        value.then(fulfillCallback)
      }
    },
    reject(error) {
      if (status !== PENDING) return
      value = makeThenable(error, REJECTED)
      if (typeof rejectCallback === 'function') {
        value.then(null, rejectCallback)
      }
      status = REJECTED
    },
    promise: {
      then: function(_fulfillCallback, _rejectCallback) {
        let newPromiseAsyncFunc = promiseAsyncFunc()
        let fulfillFunc = function(value) {
          newPromiseAsyncFunc.fulfill(_fulfillCallback(value))
        }
        let rejectFunc = function(err) {
          newPromiseAsyncFunc.fulfill(_rejectCallback(err))
        }
        if (status === PENDING) {
          fulfillCallback = fulfillFunc
          rejectCallback = rejectFunc
        } else {
          value.then(fulfillFunc, rejectFunc)
        }
        return newPromiseAsyncFunc.promise
      }
    }
  }
}

let ownPromise = function(asyncCall) {
  let defer = promiseAsyncFunc()
  try {
    asyncCall(defer.fulfill, defer.reject)
  } catch (e) {
    defer.reject(e)
  }
  return defer.promise
}

let testChainedPromise = ownPromise(function(fulfill, reject) {
  throw Error('here is an error in asyncCall')
  setTimeout(() => {
    var randomNumber = Math.random()
    if (randomNumber > 0.5) fulfill(randomNumber)
    else reject(randomNumber)
  }, 1000)
})
  .then(
    data => {
      console.log(data)
      return 'return value in then1 fulfill'
    },
    err => {
      console.log(err.message)
      return 'return value in then1 reject'
    }
  )
  .then(
    data => {
      console.log(data)
      throw Error('here is an error in fulfill1')
      return 'return value in then2 fulfill'
    },
    err => {
      console.log(err.message)
      return 'return value in then2 reject'
    }
  )
  .then(
    data => {
      console.log(data)
    },
    err => {
      console.log(err.message)
    }
  )


// console out:
Error: here is an error in asyncCall
return value in then1 reject
Error: here is an error in fulfill1
return value in then2 reject

```


### 总结
以上就是我们对于 Promise 的一个简单的实现，实现思路主要参考了 Q-A promise library for javascript。该实现的 Promise 功能较为简陋，仅实现了部分 api/规范。有任何意见和建议欢迎在评论区交流 ；）

[以上转载来源于](https://mp.weixin.qq.com/s?__biz=MzA5MjQ0Mjk2NA==&mid=2247484044&idx=1&sn=041699cff3ea2c6b5f069f167be26578&chksm=906c5ab7a71bd3a1d1defa8a50160ad16bfd8d6eca649e0940f7e0112db75bdbc9bcc308d908&scene=21#wechat_redirect)



## Es6版
比起上面的函数式实现，笔者更加喜欢下面的实现方法，清晰明了，也简单
此种实现来自于听了某讲座写出来的（手动滑稽）

```javascript
//promise.js

const PENDING = Symbol('PENDING');
const RESOLVED = Symbol('RESOLVED');
const REJECTED = Symbol('REJECTED');

const resolvePromise = (promise2, x, resolve, reject) => {
	if (promise2 === x) {
		return reject(
			new TypeError('Chaining cycle detected for promise #<promise>'))
	}
	if ((typeof x === 'object' && x !== null) || typeof x === 'function') {
		//防止多次调用成功或者失败
		let called; // 内部测试的时候,会成功和失败都调用
		try { //预防取.then的时候错误
			let then = x.then; //Object.definePropertype
			if (typeof then === 'function') {
				//没有  x.then,因为怕再次取.then的时候出错
				then.call(x, y => { //y的结果可能还是一个promise,递归调用,直到结果是一个普通值
					//resolve(y);//采用promise的成功结果向下传递
					if (called) {
						return
					}
					called = true
					resolvePromise(promise2, y, resolve, reject)
				}, r => {
					//r不再判断是否是promise,因为报错,直接传递
					if (called) {
						return
					}
					called = true
					reject(r); //失败结果向下传递
				});
			} else {
				//代表向下传递的返回值是一个普通对象
				resolve(x)
			}
		} catch (e) {
			if (called) {
				return
			}
			called = true
			reject(e)
		}

	} else {
		resolve(x)
	}
}
class Promise {
	constructor(executor) {
		this.status = PENDING;
		this.onResolvedCallbacks = [];
		this.onRejectedCallbacks = [];
		this.value = undefined;
		this.reason = undefined;
		let resolve = (value) => {
			if (this.status === PENDING) {
				this.value = value
				this.status = RESOLVED
				this.onResolvedCallbacks.forEach(fn => fn())
			}
		}
		let reject = (reason) => {
			if (this.status === PENDING) {
				this.reason = reason
				this.status = REJECTED
				this.onRejectedCallbacks.forEach(fn => fn())
			}
		}
		try {
			executor(resolve, reject)
		} catch (e) {
			reject(e)
		}
	}
	then(onfulfilled, onrejected) {
		//onfulfilled, onrejected 都是可选参数
		onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data;

		onrejected = typeof onrejected === 'function' ? onrejected : err => {
			throw err;
		}
		let promise2 = new Promise((resolve, reject) => {
			if (this.status === RESOLVED) {
				setTimeout(() => {
					try {
						const x = onfulfilled(this.value)
						resolvePromise(promise2, x, resolve, reject)
					} catch (e) {
						reject(e)
					}
				}, 0)

				return
			}
			if (this.status === REJECTED) {
				setTimeout(() => {
					try {
						const x = onrejected(this.reason)
						resolvePromise(promise2, x, resolve, reject)
					} catch (e) {
						reject(e)
					}
				}, 0)
			}
			if (this.status === PENDING) {
				this.onResolvedCallbacks.push(() => {
					setTimeout(() => {
						try {
							const x = onfulfilled(this.value)
							resolvePromise(promise2, x, resolve, reject)
						} catch (e) {
							reject(e)
						}

					}, 0)
				})
				this.onRejectedCallbacks.push(() => {
					setTimeout(() => {
						try {
							const x = onrejected(this.reason)
							resolvePromise(promise2, x, resolve, reject)
						} catch (e) {
							reject(e)
						}
					})
				})
			}
		})
		return promise2
	}
}
Promise.defer = Promise.deferred = function() {
	let dfd = {};
	dfd.promise = new Promise((resolve, reject) => {
		dfd.resolve = resolve
		dfd.reject = reject
	})
	return dfd
}

module.exports = Promise

//test
//promises-aplus-tests promise.js
```
---
layout: post
title: '手动实现一个滑动轮播图'
date: 2019-04-04
author: jiangbei
tags: function
---

**引：**曾经写过很多轮播图，移动端的居多，现在整理一下(ui图给定的轮播并不规则，我也不想在项目里因为这个小小的功能而去引一个swiper)。
清明节的时候没有回家，就整理了一下写了一个class类

**让我们来试着实现一下吧**

* 1，当手指快速滑动的时候就进入下一页，当滑动距离超过某个度量时也进入下一页
* 2，当我们定义滑动是循环的时候，当滑动到最后一页时下一页会是第一页。当我们定义不是循环的时候滑动到最后一页再往下滑会有一种划不动的感觉
* 3，滑动的时候要显示具体滑动到了哪一页
* 4，本文只考虑到了滑动和渐隐渐现的实现
* 5，我们这里不使用定时器滑动，也不适用css3的transition过渡（原因：之前这两种我都写过，我觉得requestAnimationFrame更好）



## 先定义一个类

```javascript

const time = Date.now || function () {
  return +new Date()
}
const filter = (config)=>{
	if(!config){
		return false;
	}
	return true;
}
const filterString = function(){
	if(arguments[1].indexOf(arguments[0])<0){
		return arguments[1][0]
	}
	return arguments[0];
}
const fadeFloat = 0.05;

class Swiper{
	constructor(options={}){
		this._root = document.querySelector(options.root);//根元素
		this._direction =  filterString(options.direction,['horizontal','vertical']);//定义滑动为上下还是左右
		this._loop = filter(options.loop);//是否可以循环
		this._auto = filter(options.auto);//是否自动滑动
		this._delayed = options.delayed>=2000?options.delayed:2000;//自动滑动的速度
		this._effect = filterString(options.effect,['slide','fade']);//效果是滑动还是渐隐渐现
		this._startTime = 0;//华东开始的时间戳
		this._callBack = typeof(options.callBack)==='function'?options.callBack:function(){};//每滑一下的回调函数
		this._startingPoint = 0;
		this._isTracking = false;
		this._timer = null;
		this._defaultIndex = this._loop?-1:0;
		this._slider = this._root.children[0];//滑动内容的主容器
		const children = this._slider.children;
		this._children = children;
		const length = children.length;
		this._length = length;
		this._scaleSize = this._direction === "horizontal"?children[0].getBoundingClientRect().width:children[0].getBoundingClientRect().height;
		const fadeScaleSize = children[0].getBoundingClientRect().height;
		if(this._loop&&this._effect==='slide'){
			const first = children[0].cloneNode(true);
			const last = children[length-1].cloneNode(true);
			this._slider.appendChild(first);
			this._slider.insertBefore(last,children[0]);
		}
		
		this.index = ((index)=>{
			if(typeof(index)!=='number'){
				index = 0;
			}
			if(Math.abs(index)>this._length-1){
				index = this._length-1;
			}
			
			if(this._effect==='slide'){
				if(this._loop){
					this._defaultIndex = -(index+1)
				}else{
					this._defaultIndex = -index
				}
				this._slideMove(this._defaultIndex*this._scaleSize)
			}
			if(this._effect==='fade'){
				//console.log(index)
			}
			return index;
			})(options.index);
		if(this._effect==='fade'){
			for(let i=0;i<length;i++){
				children[i].style.transform = "translate3d(0,"+(-i*fadeScaleSize)+"px,0)";
			}
			this._fadeMove(this.index,1);
		}
		
		this._numericalConversion(this._defaultIndex);
		if(this._auto){
			this._timer = this._setInterval()
		}
		const will = false;

		this._slider.addEventListener("touchstart",()=>this._start(),will);
		this._slider.addEventListener("touchmove",()=>this._move(),will);
		this._slider.addEventListener("touchend",()=>this._end(),will);
		this._slider.addEventListener('mousedown', ()=>this._start(),will)
		this._slider.addEventListener('mousemove', ()=>this._move(),will)
		this._slider.addEventListener('mouseup', ()=>this._end(),will)
		
	}
}
```

### start方法

```javascript

_start(ev){
		const e = ev || event;
		 e.preventDefault()
		const touches = e.touches;
		const target = touches ? touches[0] : e;
		this._startingPoint = this._direction === "horizontal" ? target.clientX : target.clientY;
		this._startTime = time();
		this._clear()
		this._isTracking = true;
}

```

### move方法

```javascript

_move(ev){
		if (!this._isTracking) {
		  return
		}
		const e = ev || event;
		// e.preventDefault();
		const touches = e.changedTouches;
		const target = touches ? touches[0] : e;
		const moved = this._direction === "horizontal" ? target.clientX-this._startingPoint : target.clientY-this._startingPoint;
		this._clear();
		
		const scale = Math.max(0,1-Math.abs(moved/this._scaleSize));
		const index = this.index;
		//滑动过程中根据不同的形式执行对应的方法
		switch (this._effect){
			case 'slide':
			this._moveFun(moved+this._defaultIndex*this._scaleSize,moved)
				break;
			case 'fade':
			this._fadeProcess(moved,scale);
				break;
			default:
				break;
		}
		
}

```

#### moveFun和fadeProcess方法
* 1.fadeProcess方法负责在滑动过程中，根据滑动的距离给前后页设置不同的透明度（假如从右往左滑动，我们就让当前页的透明度逐渐到0，而下一页的透明度逐渐为1）
* 2.moveFun方法根据滑动的距离让容器相应的再原有的基础上再滑动

```javascript

_moveFun(distance,moved){
	if(!this._loop){
		//不循环的时候滑到头或者尾再往前或者往后，就让滑动的距离缩小三倍
		if(distance>=0){
			distance /= 3
			this._slideMove(distance)
		}else{
			const max = this._length-1;
			if(distance<=this._scaleSize*(-max)){
				moved/=3
				distance = this._scaleSize*(-max)+moved
			}
			this._slideMove(distance)
		}
		return;
	}
	if(distance>=0){
		this._defaultIndex = -this._length;
		this._slideMove(this._defaultIndex*this._scaleSize)
	}else if(distance<=-((this._length+1)*this._scaleSize)){
		this._defaultIndex = -1;
		this._slideMove(this._defaultIndex*this._scaleSize)
	}else{
		this._slideMove(distance)
	}
	
}

_fadeProcess(moved,scale){
	//Calculate the next subscript in the sliding process, 
	//find a new coordinate, 
	//and calculate the transparency of the current and transitional coordinates according to the sliding ratio.
	const min = this._length-1;
	const oldIndex = this.index;
	let newIndex = this.index;
	if(moved<0){
		newIndex += 1;
		if(newIndex > min){
			newIndex = 0;
		}
	}else{
		newIndex -= 1;
		if(newIndex < 0){
			newIndex = min
		}
	}
	this._fadeMove(oldIndex,scale,newIndex)
}

```

#### slideMove和fadeMove

```javascript

_slideMove(distance){
	if(this._direction==="horizontal"){
		this._slider.style.transform = "translate3d("+(distance)+"px,0,0)";
	}
	if(this._direction==="vertical"){
		this._slider.style.transform = "translate3d(0,"+(distance)+"px,0)";
	}
	this._slider.style.transition = null;
}
_fadeMove(index,scale=1,oldIndex){
	let length = this._length;
	let list = this._children;
	for (let i=0;i<length;i++) {
		list[i].style.opacity = 0;
	}
	list[index].style.opacity = scale;
	if(typeof(oldIndex)==='number'){
		list[oldIndex].style.opacity = 1-scale;
	}
	
}


```

### end方法
* 1.判断：当滑动时间小于三百毫秒或者滑动距离大于某个值的时候进入下一页，否则回归原来的位置
* 2.当配置有自动滑动的时候，我们结束滑动后要再次启动定时器

```javascript

_end(ev){
	if (!this._isTracking) {
	  return
	}
	this._isTracking = false;
	const e = ev || event;
	//e.preventDefault();
	const touches = e.changedTouches;
	const target = touches ? touches[0] : e;
	let moved = this._direction === "horizontal" ? target.clientX-this._startingPoint : target.clientY-this._startingPoint;
	const stopDuration = time() - this._startTime;
	const enter = Math.abs(moved)>this._scaleSize/2 || stopDuration<300;
	const scale = Math.max(0,1-Math.abs(moved/this._scaleSize));
	const loop = this._loop;
	const oldIndex = this.index;
	const length = this._length;
	const min = this._length-1;
	const max = this._length+1;
	if(Math.abs(moved)===0){
		return 
	}
	
	if(this._effect==='fade'){
		if(enter){
			const newIndex = this._setGetIndex(moved)
			let isToNext = loop?oldIndex:null;
				this._startMove(1-scale,1,fadeFloat,newIndex,isToNext).then(res=>{
					if(this._auto){
						this._clear()
						this._timer = this._setInterval()
					}
				})
			
		}else{
			let newIndex = this.index;
			if(moved<0){
				newIndex += 1;
				if(newIndex > min){
					newIndex = 0;
				}
			}else{
				newIndex -= 1;
				if(newIndex < 0){
					newIndex = min
				}
			}
			this._startMove(scale,1,fadeFloat,this.index,newIndex).then(res=>{
				if(this._auto){
					this._clear()
					this._timer = this._setInterval()
				}
			})
		}
		return;
	}
	if(enter){
		let oldIndex = this._defaultIndex;
		if(moved>0){
			if(this._loop){
				this._defaultIndex+=1;
				if(this._defaultIndex>0){
					this._defaultIndex = 0;
				}
				if(oldIndex>0&&this._defaultIndex>0){
					//Solve Occasionally present   bug
					return;
				}
			}else{
				if(this._defaultIndex<0){
					this._defaultIndex+=1;
				}else{
					moved /= 3
				}
			}
			
		}
		if(moved<0){
			if(this._loop){
				this._defaultIndex-=1;
				if(this._defaultIndex <= -max){
					this._defaultIndex = -max
					this._slideMove(this._defaultIndex*this._scaleSize)
				}
				if(oldIndex<=-max&&this._defaultIndex<=-max){
					//Solve Occasionally present   bug
					return;
				}
			}else{
				if(Math.abs(this._defaultIndex) < min){
					this._defaultIndex-=1;
				}else{
					moved /= 3
				}
			}
			
		}
		
		
		this._numericalConversion(this._defaultIndex)
		const nowDistance = moved+oldIndex*this._scaleSize;
		const targetDistance = this._defaultIndex*this._scaleSize;
		this._startMove(nowDistance,targetDistance).then(()=>{
			if(loop){
				if(this._defaultIndex <= -max){
					//1，Solution in Cycle
					//2，Slide from the first to the first
					//3，The problem of momentary blankness caused by stopping manual sliding and triggering the timer
					this._defaultIndex = -1;
					this._slideMove(this._defaultIndex*this._scaleSize)
				}
				if(this._defaultIndex >= 0 ){
					this._defaultIndex = -length;
					this._slideMove(this._defaultIndex*this._scaleSize)
				}
			}
			
			if(this._auto){
				this._clear()
				this._timer = this._setInterval()
			}
		})
	}else{
		
		if(!this._loop){
			const distance = this._defaultIndex*this._scaleSize+moved;
			if(distance>=0){
				moved /= 3
			}else{
				if(distance<=this._scaleSize*(-min)){
					moved/=3
				}
			}
		}
		const nowDistance = this._defaultIndex*this._scaleSize+moved;
		const targetDistance = nowDistance-moved;
		this._startMove(nowDistance,targetDistance).then(()=>{
			if(this._auto){
				this._clear()
				this._timer = this._setInterval()
			}
		})
	}
}

```

#### startMove方法
* 根据某个速度将一个值以固定的速度达到另外一个值

```javascript
_startMove(nowDistance,targetDistance,speed=30,index,oldIndex){
	var n = nowDistance;
	var t = targetDistance;
	let signal = null;
	const pro = new Promise(res=>signal = res)
	const step = ()=>{
		if(n<t){
			n+=speed
			if(n>=t){
				n=t;
			}
		}else if(n>t){
			n-=speed
			if(n<=t){
				n=t;
			}
		}
		if(this._effect==='slide'){
			this._slideMove(n)
		}else{
			this._fadeMove(index,n,oldIndex)
		}
		if(nowDistance>targetDistance){
			if(n>t){
				window.requestAnimationFrame(step)
			}else{
				signal()
			}
		}
		
		if(nowDistance<targetDistance){
			if(n<t){
				window.requestAnimationFrame(step)
			}else{
				signal()
			}
		}
	}
	window.requestAnimationFrame(step)
	return pro;
}



```

##### slideMove和_fadeMove方法
* 1.slideMove方法负责让容器移动到某个位置
* 2.fadeMove方法负责让新的一页的透明度和旧的一页透明度相反

```javascript

_slideMove(distance){
	if(this._direction==="horizontal"){
		this._slider.style.transform = "translate3d("+(distance)+"px,0,0)";
	}
	if(this._direction==="vertical"){
		this._slider.style.transform = "translate3d(0,"+(distance)+"px,0)";
	}
	this._slider.style.transition = null;
}

_fadeMove(index,scale=1,oldIndex){
	let length = this._length;
	let list = this._children;
	for (let i=0;i<length;i++) {
		list[i].style.opacity = 0;
	}
	list[index].style.opacity = scale;
	if(typeof(oldIndex)==='number'){
		list[oldIndex].style.opacity = 1-scale;
	}
	
}
```

### 自动轮播
* 1.aotoplay方法是在不同的配置下，启动不同的一个定时器

```javascript
_setInterval(){
	return setInterval(()=>{
			this._aotoplay()
		},this._delayed)
}
_clear(){
	clearInterval(this._timer)
}
_aotoplay(){
	const startplay = ()=>{
		const oldIndex = this._defaultIndex;
		const max = this._length+1;
		let speed = 50
		if(this._loop){
			this._defaultIndex-=1;
			if(this._defaultIndex <= -max){
				this._defaultIndex = -max
			}
		}else{
			this._defaultIndex-=1;
			if(this._defaultIndex<=-this._length){
				this._defaultIndex = 0
			}
		}
		this._numericalConversion(this._defaultIndex)
		speed*=Math.abs(Math.abs(oldIndex)-Math.abs(this._defaultIndex))
		const nowDistance = oldIndex*this._scaleSize;
		const targetDistance = this._defaultIndex*this._scaleSize;
		this._startMove(nowDistance,targetDistance,speed).then(()=>{
			if(this._loop){
				if(this._defaultIndex <= -max){
					this._defaultIndex = -1;
					this._slideMove(this._defaultIndex*this._scaleSize);
				}
			}
		})
	}
	const fade_startplay = ()=>{
		const oldIndex = this.index;
		this.index+=1;
		if(this.index>this._length-1){
			this.index = 0
		}
		const newIndex = this.index;
		this._callBack(newIndex)
		this._startMove(0,1,fadeFloat,newIndex,oldIndex).then(res=>{
			//console.log(this.index)
		})
	}
	switch (this._effect){
		case 'slide':
		return startplay();
		case 'fade':
		return fade_startplay();
		default:
			break;
	}
	
}


```

### 向外界暴露一个点击按钮切换到某一页的函数
* 1.此方法负责手动切换到某一页
* 2.根据要切换到那一页和本页对比，使用不同的速度，，相差越大，速度越大

```javascript

moveTo(index){
	if(typeof(index) !== 'number'){
		index = 0;
	}
	index = Math.abs(parseInt(index))
	
	const max = this._length+1;
	const min = this._length-1;
	
	const speed = 50;
	
	if(index>min){
		index = min
	}
	const oldIndex = this.index;
	const newIndex = this.index = index;
	const length = this._length;
	
	if(this._effect==='fade'){
		if(newIndex === oldIndex){
			this._startMove(0,1,fadeFloat,newIndex)
		}else{
			this._callBack(newIndex)
			this._startMove(0,1,fadeFloat,newIndex,oldIndex)
		}
		return;
	}
	if(oldIndex===newIndex){
		return;
	}
	if(this._loop){
		if(index === min){
			index = -length;
			const nowDistance = this._defaultIndex*this._scaleSize;
			const targetDistance = index*this._scaleSize;
			this._defaultIndex = index;
			this._numericalConversion(this._defaultIndex);
			const s = Math.abs(oldIndex-Math.abs(this._defaultIndex))*speed<100?100:Math.abs(oldIndex-Math.abs(this._defaultIndex))*speed;
				
			this._startMove(nowDistance,targetDistance,s).then(()=>{
				//console.log(this._defaultIndex)
			})
			return;
		}
		if(index === 0){
			if(this._defaultIndex === -max){
				this._defaultIndex = -1;
				this._slideMove(this._defaultIndex*this._scaleSize)
				return;
			}
		}
		index = -index-1;
		
		const nowDistance = this._defaultIndex*this._scaleSize;
		const targetDistance = index*this._scaleSize;
		this._defaultIndex = index;
		let disparity = Math.max(Math.abs(oldIndex-Math.abs(this._defaultIndex)),3);
		const s = disparity*speed;
		this._numericalConversion(this._defaultIndex)
		this._startMove(nowDistance,targetDistance,s).then(()=>{
			
		})
	}else{
		index = -index;
		let disparity = Math.max(Math.abs(oldIndex-Math.abs(index)),3);
		const s = disparity*speed;
		const nowDistance = this._defaultIndex*this._scaleSize;
		const targetDistance = index*this._scaleSize;
		this._defaultIndex = index;
		this._startMove(nowDistance,targetDistance,s).then(()=>{
			
		})
		
	}
	
}

```

#### 辅助函数
* 1.在slide模式下，我们根据this._defaultIndex*刻度（_scaleSize）的值来判断滑动的距离
* 2.此函数负责根据this._defaultIndex的值判断index下标并返回给回调函数

```javascript

_numericalConversion(index){
	let num ;
	if(this._loop){
		switch (index){
			case -1:
			case (-(this._length+1)):
			num=0
				break;
			case 0:
			num = this._length-1
				break;
			default:
			num = Math.abs(index)-1
				break;
		}
		if(num!==this.index){
			this.index = num
		}
			
		this._callBack(this.index)
		
	}else{
		num = Math.abs(index);
		if(num!==this.index){
			this.index = num
			this._callBack(this.index)
		}
	}
	
	
}

```


### 具体使用

假如html如下
```html
<div id="root">
<div>
	<div style="background: #21374B;"><img src="img/parcel.png"/></div>
	<div style="background: #808080;"><img src="img/webpack.png"/></div>
	<div style="background: #35495E;"><img src="img/vue.png"/></div>
	<div style="background: #0E0E0E;"><img src="img/react.png"/> </div>
</div>
</div>
<div id="btns">
	<button>点击切换到第0个</button>
	<button>点击切换到第1个</button>
	<button>点击切换到第2个</button>
	<button>点击切换到第3个</button>
</div>

```



* 1，左右

```css
#root{
	height: 500px;
	width: 100%;
	overflow: hidden;
	background: moccasin;
}
#root>div{
	height: 500px;
	width: 100%;
	display: flex; 
}
#root>div>div{
	 flex-shrink:0;
	  height:  500px;
	  width: 100%;
	  line-height: 500px;
	  text-align: center;
	  display: flex;
	  justify-content: center;
}

#root img{
	align-items: center;
	display: block;
	height: 500px;
}
```


```javascript
window.onload = function(){
	const swiper = new Swiper({
		root:"#root",
		loop:true,
		auto:false,
		delayed:2000,
		effect:"slide",
		direction:"vertical",//"horizontal""vertical"
		index:0,//默认第一张
		callBack(index){
			console.log("html",index)
			document.title = "我是第"+index+"页"
		}
	})
	const btnList = document.getElementById("btns").getElementsByTagName("button");
	
	[].slice.call(btnList).forEach((dom,i)=>{
		(function (i){
			dom.onclick = function(){
				swiper.moveTo(i)
			}
		})(i)
	})
}

```

* 2，上下

```css
#root{
	height: 500px;
	width: 100%;
	overflow: hidden;
	background: moccasin;
}
#root>div{
	height: 500px;
	width: 100%;
}
#root>div>div{
	  height:  500px;
	  width: 100%;
	  line-height: 500px;
	  text-align: center;
	  display: flex;
	  justify-content: center;
}

#root img{
	align-items: center;
	display: block;
	height: 500px;
}

```


```javascript
window.onload = function(){
	const swiper = new Swiper({
		root:"#root",
		loop:true,
		auto:false,
		delayed:2000,
		effect:"slide",
		direction:"vertical",//"horizontal""vertical"
		index:0,//默认第一张
		callBack(index){
			console.log("html",index);
			document.title = "我是第"+index+"页"
		}
	})
}

```

* 3，渐隐渐显

```css
#root{
	height: 500px;
	width: 100%;
	overflow: hidden;
}
#root>div{
	height: 500px;
	width: 100%;
	position: relative;
}
#root>div>div{
	  height:  500px;
	  width: 100%;
	  position: relative;
	  left: 0;
	  top: 0;
}
#root img{
	display: block;
	height: 500px;
	width: 100%;
}

```


```javascript
window.onload = function(){
	const swiper = new Swiper({
		root:"#root",
		effect:"fade",
		loop:false,
		auto:true,
		direction:"horizontal",//"horizontal""vertical"
		index:0,//默认第一张
		callBack:function(index){
			console.log("html",index)
		}
	})
}
```


**以上：**
* 1.本文是我在完成这个功能而又修改了众多暴力测试下发现的bug之后所形成的完整代码，所以篇幅有些长
* 2.本来想捡一些主要内容说的，但是发现几乎所有的东西都很重要
* 3.代码量确实不少，但其实核心代码并不太多，大多代码是为了兼顾暴力测试的环境下
* 4.为了兼顾体验，本文并不会在一次滑动未结束之前就阻碍再一次滑动，而多数的代码都是兼顾了在这种情况下急速的滑动下所产生的bug
* 5.本人并没有去参考swiper的代码，毕竟时间有限，要做的还有很多，以上代码都是自己写出来的经验总结出来的，自己也实实在在的暴力测试了，如果还是有bug，请看到的人见谅

**后续会有更新及修改**
[完整代码见github](https://github.com/atJiangBei/small-swiper)

#### npm

```javascript

npm install small-swiper

```
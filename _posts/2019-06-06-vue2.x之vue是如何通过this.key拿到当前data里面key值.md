---
layout: post
title: 'vue是如何通过this.key拿到当前data里面key值'
date: 2019-06-06
author: jiangbei
tags: vue
---

# 代理

**示例**

```javascript

new Vue({
	el:'#app',
	data(){
		return{
			name:'vue'
		}	
	},
	methods:{
		say(){
			alert("Hello World")
		}
	},
	create(){
		this.name;// 'vue'
		this.say()
	}
})

```

很简单的例子，我们直接上源码吧（😊）

```javascript
// src/core/instance/state.js
let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}

 // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }


```


我们只分析与本节相关的内容

```javascript

data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}


const keys = Object.keys(data)
let i = keys.length
while (i--) {
	const key = keys[i]
	
	proxy(vm, `_data`, key)
}

```

我们拿到了data的值，然后遍历它，最后我们执行proxy方法，我们再来看一下proxy方法

```javascript

const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

```

以上，当我们在取this.name得时候，通过Object.defineProperty这个方法，我们无论在存取值得时候，都是对当前实例下的data操作的
---
layout: post
title: '对象的几种创建模式'
date: 2016-06-20
author: jiangbei
tags: jsBasic
---

## 工厂模式
**概念：**工厂模式是软件工程领域一种广为人知的设计模式，这模式抽象了创建具体对象的过程。用函数来封装以待定接口创建对象的细节。
```javascript
function createPerson(name,age,job){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function(){
		console.log(this.name)
	}
	return o;
}
var person1 = createPerson("阿黄",20,"前端")
var person2 = createPerson("小白",20,"前台")
```
createPerson()能够根据接受的参数创建person对象，且可以无限次的调用

## 构造函数模式

```javascript
function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = function(){
		console.log(this.name)
	}
}
var person1 = new Person("阿黄",20,"前端")
var person2 = new Person("小白",20,"前台")

console.log(person1 instanceof Person);
	//true
```

以上创建person实例，使用了new操作符，经历了**4个步骤**
* 创建了一个新对象
* 将构造函数的作用域赋给新对象，因此this就指向了这个新对象
* 执行构造函数中的代码为这个对象添加属性
* 返回新对象

**说明：**任何函数只要用new 操作符调用，那么它就是构造函数。而任何函数，不通过new 调用，那么就是普通函数。

**主要问题：**每个方法都要在实例上面创建一遍，而如上文，两个实例都重新创建了一个sayName方法，这实在没有必要，也失去了函数复用的特性


## 原型模式
**概念：**我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含包含可以由特定类型的所有实例共享的属性和方法。prototype就是通过调用构造函数而创建的那个对象实例的原型对象。

```javascript

function Person(name,age,job){}
Person.prototype.name = "阿黄";
Person.prototype.age = 20;
Person.prototype.job = "前端";
Person.prototype.sayName = function(){
	console.log(this.name)
}
	
var person1 = new Person()
var person2 = new Person()
console.log(person1.name);
//阿黄
person2.sayName()
//阿黄
console.log(Person.prototype.isPrototypeOf(person1));//true
console.log(Person.prototype.isPrototypeOf(person2));//true
console.log(Object.getPrototypeOf(person2) === Person.prototype);//true
console.log(person1.hasOwnProperty("name"));//false

person1.name = "小黑";
	
console.log(person1.hasOwnProperty("name"));//true
console.log(person1.name);
	//小黑
person1.name = null ;
console.log(person1.hasOwnProperty("name"));//true
delete person1.name;
console.log(person1.hasOwnProperty("name"));//false
console.log(person1.name);
	//阿黄
```

**以上：**person1和person2内部都有一个指针指向Person.prototype，因此使用isPrototypeOf方法返回true，
Object.getPrototypeOf()返回的对象就是原型因此全等于Person.prototype，
我们调用hasOwnProperty()方法查看却发现name并不是实例person1上的属性，而只是其原型上的属性，
重新用delete操作符删除后，name属性才会重新指向原型上的name
**in操作符：**(for in)在通过对象能够访问给定属性时返回true，无论该属性存在于实例还是原型中。

```javascript

console.log("name" in person1);//true

```

**说明：**在使用for in 循环时，返回的是所有能够通过对象访问的，可枚举(enumerated)的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在for in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的。

* **Object.keys()**接收一个参数，返回一个包含所有可枚举属性的字符串数组。

```javascript
let arr = Object.keys(person1)
console.log(arr);
//[]
arr = Object.keys(Person.prototype);
console.log(arr);
 //["name", "age", "job", "sayName"]
person1.name = "小黑";
arr = Object.keys(person1);
console.log(arr);
["name"]

```

**问题：**不能传参，所有实例同样的值，而当这些值里有引用类型的值的时候，这种问题就比较突出。 

```javascript

function Person(){}
Person.prototype = {
	constructor:Person,
	job:["前端"]
}
const person1 = new Person();
const person2 = new Person();
console.log(person1.job);//["前端"]
console.log(person2.job);//["前端"]
person1.job.push("后端");
console.log(person1.job);["前端", "后端"]
console.log(person2.job);["前端", "后端"]
```

上面代码，当person1新增了一个职业之后，person2同时也多了一个职业，这显然是不合理的

## 组合构造函数模式和原型模式

**说明：**使用构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样，每个实例都会有自己的一份实例属性的副本，但同时有共享着对方法的引用，节省内存，还可以通过构造函数传参，集合两种模式的优点于一身。

```javascript

function Person(name,age){
	this.name = name;
	this.age = age;
	this.job = ["前端"];
}
Person.prototype.sayJob = function(){
	console.log(this.job)
}
var person1 = new Person("阿黄",20)
var person2 = new Person("小白",20)
console.log(person1.job);//["前端"]
console.log(person2.job);//["前端"]
person1.job.push("后端");
console.log(person1.job);//["前端", "后端"]
console.log(person2.job);//["前端", "后端"] 
person2.sayJob();
	//["前端"] 
```

以上：当构造函数实例化之后，每个this都是独一无二指向实例的对象，所以每个实例上面的属性也互不干扰，而方法是定义在两个实例的原型上面的，这样两者都可以访问到这个方法。

## 动态原型模式

**概念：**把所有的信息都封装在构造函数中，而通过在构造函数中初始化原型（在必要的情况下）

```javascript
function Person(name,age){
	this.name = name;
	this.age = age;
	if(typeof this.sayName != 'function'){
		Person.prototype.sayName = function(){
			console.log(this.name)
		}
	}
}
var person1 = new Person("阿黄",20);
var person2 = new Person("小白",20);

```

## 寄生构造函数模式

```javascript

function Person(name,age,job){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function(){
		console.log(this.name)
	}
	return o;
}
var person1 = new Person("阿黄",20,"前端");
var person2 = new Person("小白",20,"前台");

```

上面代码构造函数中通过返回的对象o，重写了调用构造函数时所返回的值。返回的对象与构造函数或者构造函数的原型属性之间没有关系；为此不能依赖 instanceof操作符来确定对象类型。

## 稳妥构造函数模式
**说明：**所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象。适合用在一些安全环境中（禁止使用new 和 this的环境）

```javascript
function Person(name){
	var o = new Object();
	o.sayName = function(){
		console.log(name)
	}
	return o;
}
const person = Person("阿黄",20,"前端");
person.sayName();
//阿黄

```

这种模式下除了调用sayName方法，没有其他方法可以访问那么的值
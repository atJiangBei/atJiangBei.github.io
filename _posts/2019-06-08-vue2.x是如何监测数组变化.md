---
layout: post
title: '2019-06-08-vue2.x是如何监测数组变化'
date: 2019-06-08
author: jiangbei
tags: vue
---

# 响应式的数组

* 众所周知，vue2.x的响应式是通过Object.defineProperty方法实现的，但是此方法有一个问题，它无法监测数组的变化，接下来我们看一下vue是如何监测实例内数组变化从而做出响应的

**先看一个示例**
<font color="#f92672">示例</font>

```javascript

new Vue({
	el:"#app",
	template:`
	<div>
	<span v-for="(item,index) in list">{{ item }}</span>
	<button @click="change">改变数据</button>
	</div>
	`,
	data(){
		return{
			list:['a','b']
		}
	},
	methods:{
		change(){
			this.list.splice(2,0,'c')
			setTimeout(()=>{
				this.list[1] = 'd'
				console.log(this.list);//a,d,c
			},2000)
		}
	}
})


```

以上，当我们点击按钮后，执行change方法，页面会渲染为

```html

<span>a</span>
<span>b</span>
<span>c</span>

```

* 两秒后，第二个span的内容却依然是b，而不是d，然而我们输出list发现，数据已经变为[a,d,c]，为什么数据改变而内容却没有更新呢  
* 我们看一下vue内部是怎么实现监听的

**初始化数据的时候，有这么一个函数**

```javascript
// src/core/instance/state.js

function initData (vm: Component) {
//···
//...
  // observe data
  observe(data, true /* asRootData */)
}

//observe方法
// src/core/observer/index.js

export function observe (value: any, asRootData: ?boolean): Observer | void {
  //···
  ob = new Observer(value)
  //···
}

// class Observer
//

class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}

```

以上可以看到，当处理数据的时候，如果判断当前数据是个数组，我们将会走这几行代码

```javascript

if (hasProto) {
	protoAugment(value, arrayMethods)
} else {
	copyAugment(value, arrayMethods, arrayKeys)
}
this.observeArray(value)

```

## 支持__proto__

一般情况下，hasProto（判断当前浏览器是否支持__proto__属性）都会为true，所以我们先来看一下protoAugment(value, arrayMethods)做了什么

```javascript
// src/core/observer/index.js
/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src: Object) {
  /* eslint-disable no-proto */
  target.__proto__ = src
  /* eslint-enable no-proto */
}

```

可以看出，此方法只是把当前array的原型设为 arrayMethods，我们再来看一下 arrayMethods

```javascript
// src/core/observer/array.js
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})

//def

function def (obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}


```

**分析：**以上我们显示拿到了Array的原型对象，然后我们再把此对象设置为arrayMethods的原型，
此时，arrayMethods是这个样子

```javascript

{
	__proto__: Array(0)
		concat: ƒ concat()
		constructor: ƒ Array()
		copyWithin: ƒ copyWithin()
		entries: ƒ entries()
		every: ƒ every()
		fill: ƒ fill()
		filter: ƒ filter()
		find: ƒ find()
		findIndex: ƒ findIndex()
		flat: ƒ flat()
		flatMap: ƒ flatMap()
		forEach: ƒ forEach()
		includes: ƒ includes()
		indexOf: ƒ indexOf()
		join: ƒ join()
		keys: ƒ keys()
		lastIndexOf: ƒ lastIndexOf()
		length: 0
		map: ƒ map()
		pop: ƒ pop()
}

```

然后我们在遍历methodsToPatch的时候执行def方法后，arrayMethods如下

```javascript

{
	pop: ƒ mutator(...args)
	push: ƒ mutator(...args)
	reverse: ƒ mutator(...args)
	shift: ƒ mutator(...args)
	sort: ƒ mutator(...args)
	splice: ƒ mutator(...args)
	unshift: ƒ mutator(...args)
	__proto__: Array(0)
		concat: ƒ concat()
		constructor: ƒ Array()
		copyWithin: ƒ copyWithin()
		entries: ƒ entries()
		every: ƒ every()
		fill: ƒ fill()
		filter: ƒ filter()
		find: ƒ find()
		findIndex: ƒ findIndex()
		flat: ƒ flat()
		flatMap: ƒ flatMap()
		forEach: ƒ forEach()
		includes: ƒ includes()
		indexOf: ƒ indexOf()
		join: ƒ join()
		keys: ƒ keys()
		lastIndexOf: ƒ lastIndexOf()
		length: 0
		map: ƒ map()
		pop: ƒ pop()
}


```

此时push，pop，shift，unshift，splice，sort，reverse等方法都重写为了mutator函数

```javascript

function mutator (...args) {
	const result = original.apply(this, args)
	const ob = this.__ob__
	let inserted
	switch (method) {
	  case 'push':
	  case 'unshift':
		inserted = args
		break
	  case 'splice':
		inserted = args.slice(2)
		break
	}
	if (inserted) ob.observeArray(inserted)
	// notify change
	ob.dep.notify()
	return result
}

```

回到最初，当我们在执行protoAugment(value, arrayMethods)方法时，就是把数组value的原型指向了arrayMethods，
所以在操作数组push，pop，shift...这些方法时我们可以在mutator内部做一些操作，例如ob.dep.notify()通知更新

## 不支持__proto__时

```javascript

function def (obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}

function copyAugment (target: Object, src: Object, keys: Array<string>) {
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}
const arrayKeys = Object.getOwnPropertyNames(arrayMethods)
//arrayKeys-> ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"]
copyAugment(value, arrayMethods, arrayKeys)

```

**分析：**当浏览器不支持直接把数组原型以__proto__的形式指向arrayMethods时，我们就直接给当前数组本身添加这些经过我们改写的方法，也就是mutator函数  

* 这也就是为什么在vue2.x里面，我们直接this.arr[i] = xxx 并不能让视图响应的原因

## 本地测试

```javascript

const arrayMethods = ['splice','push'];
const prototypeArray = Array.prototype;
const protoArray = Object.create(prototypeArray);
const setValue = function(target,key,value){
	Object.defineProperty(target, key, {
		value: value,
		enumerable: true,
		writable: true,
		configurable: true
	})
}

const arr = [1,2,3];
arrayMethods.forEach((method)=>{
	const original = prototypeArray[method]
	setValue(protoArray,method,function mutator(...arg){
		original.apply(this,arg)
		console.log(arg)
		console.log(`执行了${method}方法，传入的参数为${arg}`)
	})
})

arr.__proto__ = protoArray

arr.push(4);//执行了push方法，传入的参数为4
arr.splice(3,1);//执行了splice方法，传入的参数为3,1

```

**注意：这样我们在调用call,push等方法时，就一定要调用我们改写过的方法，请看下面示例**

```javascript

[].push.apply(arr,[5,6]);//并不会触发我们的输出，因为此时调用的是原始push的方法
console.log(arr);//[1, 2, 3, 5, 6]
arr.push.apply(arr,[7,8,9]);//执行了push方法，传入的参数为7,8,9
console.log(arr);//[1, 2, 3, 5, 6, 7, 8, 9]

```
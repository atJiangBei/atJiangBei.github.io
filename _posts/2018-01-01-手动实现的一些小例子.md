---
layout: post
title: '手动实现的一些小例子，持续更新'
date: 2018-01-01
author: jiangbei
tags: jsSenior
---

## 实现一个new操作符

```javascript
function Person(name,age){
	this.name = name
	this.age = age
}
Person.prototype.sayName = function(){
	console.log(this.name)
}

function New(fn){
	const obj = {};
	const arr = [].slice.call(arguments,1)
	fn.apply(obj,arr)
	Object.setPrototypeOf(obj,fn.prototype)
	return obj;
}
const obj = New(Person,"小米",18);
console.log(obj)
console.log(obj instanceof Person);//true

```

## instanceof
**定义：**instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性
**例子**
```javascript
class A{
	
}
class B extends A{
	
}
const b = new B();
console.log(b instanceof B);//true
console.log(b instanceof A);//true

function ins_tanceof(cu,pr){
	let _pro = cu.__proto__;
	let pro = pr.prototype;
	while(true){
		if(_pro === null){
			return false;
		}
		if(_pro === pro){
			return true;
		}
		_pro = _pro.__proto__;
	}
}
console.log(ins_tanceof(b,B))
console.log(ins_tanceof(b,A))


```

## call

```javascript

Function.prototype.myCall = function(){
	const arr = [...arguments];
	const obj = arr.shift() || window;
	obj.fn = this;
	const result = obj.fn(...arr);
	delete obj.fn
	return result;
}
	
console.log(Math.max.myCall(null,1,2,3))


```

## apply

```javascript

Function.prototype.myApply = function(){
	const arr = [...arguments];
	const obj = arr[0] || window;
	obj.fn = this;
	const result = obj.fn(...arr[1]);
	delete obj.fn
	return result;
}
console.log(Math.max.myApply(null,[1,2,5]))


```

## bind

```javascript

Function.prototype.myBind = function(){
	const _this = this;
	const fn = [].shift.call(arguments) || window;
	return function(){
		return _this.apply(fn,arguments)
	}
}


console.log(Math.max.myBind(null)(1,3,6))


```

## reduce

```javascript

Array.prototype.myReduce = function(fn, initial) {
	if (!this.length) return;
	let inititaval;
	let i = 0;
	if(initial){
		 inititaval = initial 
	}else{
		i++
		inititaval = this.slice(0, 1)[0];
	}
	
	for (;i < this.length; i++) {
		inititaval = fn(inititaval,this[i],i,this)
	}
	return inititaval
}

//test

const total = attr.myReduce((total, currentValue, currentIndex, arr) => {
	console.log(total, currentValue, currentIndex, arr)
	return total+=currentValue
},2)
console.log(total)

```

## 用setTimout实现一个setInterval

```javascript

function set_Interval(fn,ms){
	set_Interval.run = true;
	const args = [].splice.call(arguments,2);
	function callBack(){
		fn.apply(null,args)
		start()
	}
	function start(){
		if(set_Interval.run)setTimeout(callBack,ms)
	}
	start()
}

function clear_Interval(){
	set_Interval.run = false;
}
set_Interval(function(a,b){
	console.log(a,b)
},1000,1,2)
document.getElementById("btn").onclick = function(){
	clear_Interval()
}


```

* __setTimout函数的第一个参数为执行函数，第二个参数为时间，后面为传参。
* 缺点：如果启动多个__setTimout，那么每次清除都相当于清除所有的

```javascript

Function.prototype.set_Interval = function(ms){
	const _this = this;
	_this.run = true;
	const args = [].splice.call(arguments,1);
	function callBack(){
		_this.apply(null,args)
		start()
	}
	function start(){
		if(_this.run)setTimeout(callBack,ms)
	}
	start()
	_this.clear_Interval = function(){
		_this.run = false;
	}
}
const con = function(a){
	console.log(a)
}
const er = function(a){
	console.log(a)
}
con.set_Interval(1000,1)
er.set_Interval(1000,2)
document.getElementById("btn").onclick = function(){
	con.clear_Interval()
}


```

缺点：没办法像原生定时器那样定时匿名函数，每个函数下面又挂载了一个这样的方法

## reduce

```javascript

Array.prototype.myReduce = function(fn, initial) {
	if (!this.length) return;
	let inititaval;
	let i = 0;
	if (initial) {
		inititaval = initial
	} else {
		i++
		inititaval = this.slice(0, 1)[0];
	}
	for (; i < this.length; i++) {
		inititaval = fn(inititaval, this[i], i, this)
	}
	return inititaval
}

const attr = [1, 2, 3, 4, 5, 6];
const total = attr.myReduce((total, currentValue, currentIndex, arr) => {
	console.log(total, currentValue, currentIndex, arr)
	return total += currentValue
})
console.log(total)
//控制台
1 2 1 [1, 2, 3, 4, 5, 6]
3 3 2 [1, 2, 3, 4, 5, 6]
6 4 3 [1, 2, 3, 4, 5, 6]
10 5 4 [1, 2, 3, 4, 5, 6]
15 6 5 [1, 2, 3, 4, 5, 6]
21

```
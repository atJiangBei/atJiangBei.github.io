---
layout: post
title: 'webpack之性能优化'
date: 2020-01-11
author: jiangbei
tags: webpack
---

**寄语：**  <font color="#2ca6cb">如果你觉得性能优化不够重要，那么一定是你的项目不够复杂</font>  
**本文主要面对webpack4.x**

前戏就不必了，我们直接开始吧（急性子）


## 目录筛选优化：

```javascript
// 例
// webpack.config.js
{
    test: /\.js$/,
    loader: 'babel-loader?cacheDirectory',//开启缓存
    include: path.resolve(__dirname, 'src'),//
    exclude: path.resolve(__dirname,' ./node_modules'),//排除node_modules目录下
}

```

## resolve.modules

* 告诉 webpack 解析模块时应该搜索的目录
* 默认是['node_modules']，但是，它会先去当前目录的./node_modules查找，没有的话再去../node_modules最后到根目录，一般我们第三方模块都是安装在根目录，所以就没有必要再一层层的找，而是直接给定绝对路径

```javascript

{
	resolve:{
		modules: [path.resolve(__dirname, "node_modules")]
	}
}

```

## resolve.alias

* 使用resolve.alias创建 import 或 require 的别名，来确保模块引入变得更简单。例如，一些位于 src/ 文件夹下的常用模块

```javascript

{
	resolve:{
		alias:{
			'@': path.resolve(__dirname, "src"),
			'utils':path.resolve(__dirname, "src/utils"),
			'http':path.resolve(__dirname, "src/http"),
		}
	}
}

```


## resolve.extensions

* 自动解析确定的扩展。默认值为：extensions: [".js", ".json"]
* 能够使用户在引入模块时不带扩展
* 如下配置，当用户在 require("./index") 时候，会先寻找index.vue文件，找不到会再去寻找index.js文件，以此类推，如果列表越长，找的次数就越多，因此我们尽量把更常用的放在最前面，并且列表尽可能地少
* 

```javascript
{
	resolve:{
		extensions:[".vue",".js",".jsx",".json"]
	}
}

```

## module.noParse

* RegExp | [RegExp] | function（从 webpack 3.0.0 开始）
* 防止 webpack 解析那些任何与给定正则表达式相匹配的文件。
* 面向为没有外部依赖的包。忽略大型的 library 可以提高构建性能。  

```javascript

{
	module:{
		noParse: /jquery|lodash/
	}
}

```

## terser-webpack-plugin

* 好多博客说，官方提供的UglifyJsPlugin('uglifyjs-webpack-plugin')是单线程的不能并行，
* 可是此插件配置项的parallel，官方说明：parallel: true 启用并行化。默认并发运行次数：os.cpus().length - 1.

```javascript
//webpack说明地址
//https://webpack.js.org/plugins/uglifyjs-webpack-plugin/

optimization:{
	minimizer:[
	  new UglifyJsPlugin({
	    parallel: true
	  })
	]
}

```

* webpack4官方又提供了一个新的插件，也就是[terser-webpack-plugin](https://webpack.js.org/plugins/terser-webpack-plugin/)
* 经过测试，当我的项目使用[uglifyjs-webpack-plugin](https://webpack.js.org/plugins/uglifyjs-webpack-plugin/)时，时间为6秒左右，使用uglifyjs-webpack-plugin，基本为4秒，真的是快了好多

```javascript
//webpack说明地址
//https://webpack.js.org/plugins/terser-webpack-plugin/

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin(),
    ],
  },
};

```


## splitChunks

* 从webpack诉4，CommonsChunkPlugin被移除
* 有时候打包之后当我们的.js文件过大时，我们需要利用此配置进行拆分成更小的包，


```javascript

module.exports = {
  //...
  optimization: {
	splitChunks: {
	// 这表明将选择哪些块进行优化。提供字符串时，有效值为all, async，和initial。
	//提供all可能特别强大，因为这意味着即使在异步块和非异步块之间也可以共享块。
		chunks: 'all',
	//生成快的最小字节
		minSize: 30000,
		minRemainingSize: 0,
		//maxSize选项用于HTTP/2和长期缓存。它增加了请求计数，以获得更好的缓存。
		//它还可用于缩小文件大小，以加快重建速度。
		maxSize: 0,
		//在拆分之前必须共享模块的最少块数。
		minChunks: 1,
		//当按需加载时，并行请求的最大数量。
		maxAsyncRequests: 6,
		//入口点的最大并行请求数。
		maxInitialRequests: 4,
		//默认情况下，webpack将使用块的来源和名称生成名称(例如：vendors~main.js)。
		//此选项允许您为生成的名称指定要使用的分隔符。
		automaticNameDelimiter: '~',
		//对象生成的块名称的最大字符计数。SplitChunksPlugin.
		automaticNameMaxLength: 30,
		cacheGroups: {
		  defaultVendors: {
			test: /[\\/]node_modules[\\/]/,
			priority: -10
		  },
		  default: {
			minChunks: 2,
			priority: -20,
			reuseExistingChunk: true
		  }
		}
    }
  }
};


```



## happypack

* 开启多线程打包
* 更详细的用法见[npm文档](https://www.npmjs.com/package/happypack)
* 用法如下

```javascript

var HappyPack = require('happypack');
var happyThreadPool = HappyPack.ThreadPool({ size: 5 });
 
module.exports = {
  module: {
      rules: [
        {
          test: /\.js$/,
          //把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行
          loader: 'happypack/loader?id=happyBabelJs',
          //排除node_modules 目录下的文件
          exclude: /node_modules/
        },
		{
		    test: /\.less$/,
		    use: 'happypack/loader?id=happyBabelStyles'
		}
      ]
    },
  plugins: [
    new HappyPack({
      id: 'happyBabelJs',
      threadPool: happyThreadPool,
      loaders: [ 'babel-loader' ]
    }),
 
    new HappyPack({
      id: 'happyBabelStyles',
      threadPool: happyThreadPool,
      loaders: [ 'style-loader', 'css-loader', 'less-loader' ]
    })
  ]
};

```

**说明1：**
* 在我司的一个大型项目中，使用happypack有着明显卓越的成效


**说明2（来自作者的寄语）：**

* My interest in the project is fading away mainly because I'm not using JavaScript as much as I was in the past. Additionally, Webpack's native performance is improving and (I hope) it will soon make this plugin unnecessary.
* 我对这个项目的兴趣正在减弱，主要是因为我没有像过去那样多地使用JavaScript。此外，webpack的表现也正在改善，而且(我希望)它很快就会使这个插件变得不必要

##未完待续...##
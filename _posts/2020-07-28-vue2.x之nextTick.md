---
layout: post
title: 'vue2.x之nextTick'
date: 2020-07-28
author: jiangbei
tags: vue
---


# nextTick

也看过不少介绍nextTick的文章，大多都说的比较浅，而且也并不完整，可能介绍了为什么给我们暴露了这个api，却没有介绍内部为什么要引入这个api，内部引入这个api做了什么

**本文默认读者已经理解了js宏任务和微任务的基本概念**


## vue为什么要引入 nextTick

vue的响应式原理就不再赘述，先看一段代码

假设我们的dom如下所示

```html

<div id="app"></div>

```



```js

//我们先获取一下dom
const app = document.getElementById("app");

// 创建data数据

const data = {
	count:0
}

//渲染函数

function render(){
	console.log("渲染")
	app.innerHTML = data.count;
}

//更新函数

function update(){
	render()
}

// 响应式函数

function define(obj,key,val){
	Object.defineProperty(obj,key,{
		set(nvl){
			if(nvl === val){
				return;
			}
			val = nvl;
			//数据修改时执行我们的更新函数
			update(key)
		},
		get(){
			return val
		}
	})
}

//劫持我们的数据对象

define(data,"count",data["count"])

//执行渲染函数

render()

//输出：渲染

/*
此时的dom
<div id="app">0</div>
*/

```

**以上：我们先是定义了一个对象data，然后按照国际惯例劫持它的count属性，在count改变时，我们去更新dom**

测试：此时app的内容为0，我们在一秒后去更改count的值

```js

setTimeout(()=>{
	
	data.count = 1;
	data.count = 2;
	data.count = 3;
	
},1000)

/*
此时的dom
<div id="app">3</div>
*/

//再次输出三次渲染
"渲染"
"渲染"
"渲染"

```

**以上：我们一共更新了三次 count 所以app更新了三次，好像没什么问题，但是视觉效果上看，页面是从0直接到3到，我们应该在同一事件循环内直接取count最后的值就可以了，不必要做重复的渲染**

## nextTick

做法：在每次修改count时，我们可以把渲染函数存起来，在修改结束后再执行渲染


```js

let map = {};
let flag = true;
function run(){
	flag = true;
	const copies = map;
	map = {};
	for (let key in copies) {
		copies[key]()
	}
}
function $nextTick(cb,key){
	map[key] = cb;
	if(flag){
		flag = false;
		run()
	}
}

//修改一下update函数 

function update(key){
	$nextTick(render,key)
}

```

**以上：我们创建了一个对象用于存储渲染函数，以劫持的属性key作为对象的key(为了去重)**

测试：

```js

setTimeout(()=>{
	
	data.count = 1;
	data.count = 2;
	data.count = 3;
	
},1000)

//再次输出三次渲染
"渲染"
"渲染"
"渲染"


```

依旧不行，我们上面 虽然是把函数以key的方式去了重，但是我们每次 “存” 和 “放” 都在一个 任务里，所以我们上面的代码执行的流程是

更新为1->render函数存入map->map置为空->遍历map对象执行 
更新为2->render函数存入map->map置为空->遍历map对象执行 
更新为3->render函数存入map->map置为空->遍历map对象执行 

所以我们要做的就是，更新为1->render函数存入map，更新为2->render函数存入map，更新为3->render函数存入map，map置为空->遍历map对象执行

## 引入微任务

**修改代码**

```js

//add代码
const timerFn = ()=>{
	Promise.resolve().then(run)
}

//修改代码
function $nextTick(cb,key){
	if(key){
		map.set(cb,cb)
	}else{
		map.set(id++,cb)
	}
	if(flag){
		flag = false;
		timerFn()
	}
}

//测试
setTimeout(()=>{
	
	data.count = 1;
	data.count = 2;
	data.count = 3;
	
},1000)

//只有一次输出

"渲染"

```


**以上：我们要做的基本实现，在同一个事件循环里我们修改了三次数据，然后只执行了一次更新，达到了我们的预期，但是我们依旧有一个问题，如下**

```js
setTimeout(()=>{
	
	data.count = 1;
	data.count = 2;
	data.count = 3;
	console.log(app.innerHTML)
	//输出  0
},1000)


```

**以上：这显然是不合理的，所以我们要如何拿到改变后的值呢？**

## 暴露出来的api nextTick

我们可以把我们的代码修改一下

```js

let id = 0;
function $nextTick(cb,key){
	if(key){
		map[key] = cb;
	}else{
		map[id++] = cb;
	}
	if(flag){
		flag = false;
		timerFn()
	}
}


//测试

setTimeout(()=>{
	data.count = 1;
	data.count = 2;
	data.count = 3;
	
	$nextTick(()=>{
		console.log(app.innerHTML);//0
	})
},1000)

```

结果：依旧失败

分析原因：当我们用for in遍历map对象时，并不是我们后面加入的值就一定在后面，所以我们再次修改一下代码 

## nextTick 2

修改代码我们把map改为Map

```js

let map = new Map();
let flag = true;
const timerFn = ()=>{
	Promise.resolve().then(run)
}
function run(){
	flag = true;
	const copies = map;
	map = new Map();
	for (let [key,fn] of copies) {
		fn()
	}
}
function $nextTick(cb,key){
	if(key){
		map.set(cb,cb)
	}else{
		map.set(id++,cb)
	}
	if(flag){
		flag = false;
		timerFn()
	}
}


setTimeout(()=>{
	data.count = 1;
	data.count = 2;
	data.count = 3;
	
	$nextTick(()=>{
		console.log(app.innerHTML);
		// 3
	})
},1000)


```

**以上：我们利用了Map有序的执行了回调函数，达成了我们要的效果**
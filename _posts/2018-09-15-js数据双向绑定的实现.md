---
layout: post
title: 'js数据双向绑定的实现'
date: 2018-09-15
author: jiangbei
tags: vue
---

# 深入响应式原理
Vue.js最显著的功能就是响应式系统，它是一个典型的MVVM框架，模型(Model)只是普通的javascript对象，修改它则视图(View)会自动更新。
这种设计让状态管理变得非常简单而直观。

**思路：**
* 实现一个监察者(Observer)进行对数据(data)的监听，并且提供一个订阅器，收集订阅者
* 实现一个解析器(Compile)把根元素下面的节点编译成一段document fragment，然后解析其中的指令(Directive)，得到每一个指令所依赖的数据项和update方法
* 实现一个订阅者Watcher，把指令(Directive)中的数据依赖通过Watcher订阅在对象数据的Observer的Dep上。当数据变化时，就会触发该数据的那个Observer的Dep上的notify方法通知对应的Watcher的update，进而触发指令(Directive)的update方法来更新DOM视图


## 监察者Observer
* 依靠**Object.defineProperty()**方法进行数据劫持

1,先实现一个订阅器待会儿在数据劫持函数里面我们可以用来收集每个数据的订阅者（我们这里仅实现一层）

```javascript
class Dep {
	
  constructor () {
    this.subs = []
  }

  addSub (sub) {
    this.subs.push(sub)
  }

  notify () {
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

Dep.target = null

```

2,创建监察者

```javascript
function defineReactive(data,key,val){
		var dep = new Dep();
		observe(val);
		//其实对于本文来说这个递归调用并没有什么意义，因为本文实现只在一层数据的情况下
		Object.defineProperty(data,key,{
			enumerable: true,
			configurable: true,
			get:function reactiveGetter(){
				if (Dep.target) {
				    dep.addSub(Dep.target);
				}
				return val
			},
			set:function reactiveSetter(newVal){
				if(newVal === val){
					return;
				}
				val = newVal;
				dep.notify();
				
			}
		})
}

class Observer {
  constructor (value) {
    this.value = value
    this.walk(value)
  }
  walk(obj){
  	const keys = Object.keys(obj)
  	for (let i = 0; i < keys.length; i++) {
  	  defineReactive(obj, keys[i],obj[keys[i]])
  	}
  }
}

function observe(value, vm) {
	if (!value || typeof value !== 'object') {
		return;
	}
	return new Observer(value);
};

```

以上：每一个数据都会有一个属于自己的Observer，假如我们监听的数据为{name:"小明",age:18}，那么将会实例化两个Observer，
Dep.target可以看作为一个全局的变量，当我们在某条数据下每增加一个订阅者()时，就会把该订阅者添加到该观察者的dep数组里，
当我们改变这个数据的值的时候，就会触发该数据的set函数，从而执行该dep的notify方法，而notify方法会通知所有订阅了该数据的订阅者，
而该订阅会触发回调函数，我们可以在该回调函数里面执行我们要更新的视图


## 订阅者Watcher

```javascript

class Watcher{
	constructor(vm, exp, cb) {
		this.cb = cb;
		this.vm = vm;
		this.exp = exp;
		this.value = this.get();
	}
	update() {
	    this.run();
	}
	run() {
	    var value = this.vm.data[this.exp];
		//以上我们这里只取data的第一层
	    var oldVal = this.value;
	    if (value !== oldVal) {
	        this.value = value;
	        this.cb.call(this.vm, value, oldVal);
	    }
	}
	get() {
	    Dep.target = this;
	    var value = this.vm.data[this.exp]；
	    Dep.target = null;
	    return value;
	}
}


```

以上：每初始化一次执行get方法，把当前this添加到该数据的用来收集订阅者的订阅器dep数组里，
这样就把watcher和订阅器连接在一起，在监听的数据执行set方法时，调用每个订阅当前数据的订阅者的update()方法

## 解析器

**思考：**上面我们已经监听了数据，我们现在要做的是
* 1，把根节点内所有的dom节点编译成fragment片段
* 2，初始化，遍历所有的节点解析其指令和模板插值（我们这里只解析双括号插值法，v-model，v-text，v-on）
* 3，在对应的数据下我们添加订阅者
* 4，把节点片段放入根节点

**判断节点和指令**

```javascript

const parsedirectives = {
	isDirective (attr) {
	    return attr.indexOf('v-') === 0;
	},
	isEventDirective (dir) {
	    return dir.indexOf('on:') === 0;
	},
	isTextDirective (dir) {
	    return dir.indexOf('text') === 0;
	},
}
const parsenode = {
	isElementNode (node) {
	    return node.nodeType === 1;
	},
	isTextNode (node) {
	    return node.nodeType === 3;
	},
	isFormNode (node) {
		return node.tagName === "TEXTAREA" || node.tagName === "INPUT"
	}
}


```

**实现解析类**

```javascript

class Compile{
	constructor(el, vm) {
		this.vm = vm;
		this.el = document.querySelector(el);
		this.fragment = null;
		this.init();
	}
    init () {
        if (this.el) {
            this.fragment = this.nodeToFragment(this.el);
            this.compileElement(this.fragment);
            this.el.appendChild(this.fragment);
        } else {
            console.log('Dom元素不存在');
        }
    }
    nodeToFragment (el) {
        var fragment = document.createDocumentFragment();
        var child = el.firstChild;
        while (child) {
            fragment.appendChild(child);
            child = el.firstChild
        }
        return fragment;
    }
    compileElement (el) {
        var childNodes = el.childNodes;
        var self = this;
        [].slice.call(childNodes).forEach(function(node) {
            var reg = /\{\{(.*)\}\}/;
            var text = node.textContent;
            if (parsenode.isElementNode(node)) {  
                self.compile(node);
            } else if (parsenode.isTextNode(node) && reg.test(text)) {
                self.compileText(node, reg.exec(text)[1]);
            }

            if (node.childNodes && node.childNodes.length) {
                self.compileElement(node);
            }
        });
    }
    compile (node) {
        var nodeAttrs = node.attributes;
        var self = this;
        [].forEach.call(nodeAttrs, function(attr) {
            var attrName = attr.name;
            if (parsedirectives.isDirective(attrName)) {
                var exp = attr.value;
                var dir = attrName.substring(2);
                if (parsedirectives.isEventDirective(dir)) {  // 事件指令
                    self.compileEvent(node, self.vm, exp, dir);
                } else if(parsedirectives.isTextDirective(dir)){
					self.compileinnerText(node,exp)
				} else{  // v-model 指令
                    self.compileModel(node, self.vm, exp, dir);
                }
                node.removeAttribute(attrName);
            }
        });
    }
    compileText (node, exp) {
        const self = this;
        const initText = this.vm[exp];
        this.updateText(node, initText);
        new Watcher(this.vm, exp, function (value) {
            self.updateText(node, value);
        });
    }
    compileEvent (node, vm, exp, dir) {
        var eventType = dir.split(':')[1];
        var cb = vm.methods && vm.methods[exp];

        if (eventType && cb) {
            node.addEventListener(eventType, cb.bind(vm), false);
        }
    }
	compileinnerText (node,exp) {
		this.compileText(node,exp)
	}
    compileModel (node, vm, exp, dir) {
		
        var self = this;
        var val = this.vm[exp];
        this.modelUpdater(node, val);
        new Watcher(this.vm, exp, function (value) {
			self.modelUpdater(node, value);
        });
        node.addEventListener('input', function(e) {
            var newValue = e.target.value;
            if (val === newValue) {
                return;
            }
            self.vm[exp] = newValue;
            val = newValue;
        });
    }
    updateText (node, value) {
        node.textContent = typeof value == 'undefined' ? '' : value;
    }
    modelUpdater (node, value, oldValue) {
		node.value = value
    }
}

```

## 创建一个双向绑定的类把以上结合起来

```javascript
class Vue{
	constructor(options){
		var self = this;
		this.data = options.data;
		this.methods = options.methods;
		Object.keys(this.data).forEach(function(key) {
		    self.proxyKeys(key);
		});
		observe(this.data);
		
		new Compile(options.el, this);
	}
	proxyKeys(key) {
	    var self = this;
	    Object.defineProperty(this, key, {
	        enumerable: false,
	        configurable: true,
	        get: function getter () {
	            return self.data[key];
	        },
	        set: function setter (newVal) {
	            self.data[key] = newVal;
	        }
	    });
	}
}


```

**试验一下**

```html
<div id="root">
	<h1>
		<span>{{name}}<span>
		<span>{{age}}了</span>
	</h1>
	<p><input v-model="name" /></p>
	<p><textarea v-model="name"></textarea></p>
	<h2 v-text="name">呵呵<span></span></h2>
	<button v-on:click="addAge">长大</button>
</div>


```



```javascript

new Vue({
	el:"#root",
	data:{
		name:"小明",
		age:18,
	},
	methods:{
		addAge(){
			this.age++
		}
	}
})

```

缺陷：
* 1，只能解析一层数据，例如不能{{person.name}}
* 2，模板插值法会把该节点内的元素替换掉，例如<span>我是{{name}}</span>替换为<span>小明</span>

[github地址](https://github.com/atJiangBei/binding)
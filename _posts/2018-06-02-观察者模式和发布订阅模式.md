---
layout: post
title: '观察者模式和发布订阅模式'
date: 2018-06-02
author: jiangbei
tags: designPattern
---


# 前言

* 有人说观察者模式就是发布订阅模式，
* 阮一峰老师在[javascript的四种异步编程](http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html)里面
是这么形容的：我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，
从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）。
* 在《javascript模式》这本书的第十五章观察者模式第一段话是这么说的，观察者模式（又名发布者-订阅者（publisher-subscriber）模式）是一种管理人与其任务之间的关系的得力工具。

**《JavaScript Design Patterns》中是这样解释的：**
* 虽然观察者模式很有用，但在JavaScript世界中，我们常常会发现它通常使用称为发布/订阅模式的变体来实现。虽然非常相似，但值得注意的是这些模式之间存在差异。

**具体不同点：**
* 1、观察者模式要求想要接受相关通知的观察者必须到发起这个事件的被观察者上注册这个事件
* 2、发布/订阅模式使用一个主题/事件频道，这个频道处于想要获取通知的订阅者和发起事件的发布者之间。这个事件系统允许代码定义应用相关的事件，这个事件可以传递特殊的参数，参数中包含有订阅者所需要的值。这种想法是为了避免订阅者和发布者之间的依赖性。
* 3、Observer模式不同，因为它允许任何实现适当事件处理程序的订阅者注册和接收发布者广播的主题通知。

**通俗点的解释：**
**观察者模式：**
假如现在有一个楼盘将要开盘（这个楼盘是一个主体，里面有销售人员，有保安人员等等），
然后有很多人（很多观察者）来买房，然后这些人把自己的电话留在售楼部（每个观察者都把自己注册到目标），
当确定楼盘开盘日期的时候，就由售楼部的销售人员通知这些留下电话的买房的人。
在这里，买房的人必须把自己的电话号码留在售楼部（观察者必须把自己注册到主体里），
不然楼盘的销售人员是无法通知要买房的人的，这之间就产生了联系。
**发布订阅模式：**
假设有一个中介，有很多想把自己的房子卖了的人，就把自己的房产信息留下。
然后有很多想要买二手房的人，把自己的电话也留在了中介。
这之间，买房的和卖房的一点关系都没有，谁都不知道谁的存在，买房的等着中介通知它有没有房。

还是不懂？看代码吧

## 发布订阅模式具体实现代码

```javascript

	var pubsub = {};
 
(function(myObject) {

    var topics = {};

    var subUid = -1;
    myObject.publish = function( topic, args ) {
 
        if ( !topics[topic] ) {
            return false;
        }
 
        var subscribers = topics[topic],
            len = subscribers ? subscribers.length : 0;
 
        while (len--) {
            subscribers[len].func( topic, args );
        }
 
        return this;
    };
 
    myObject.subscribe = function( topic, func ) {
 
        if (!topics[topic]) {
            topics[topic] = [];
        }
 
        var token = ( ++subUid ).toString();
        topics[topic].push({
            token: token,
            func: func
        });
        return token;
    };
 
    myObject.unsubscribe = function( token ) {
        for ( var m in topics ) {
            if ( topics[m] ) {
                for ( var i = 0, j = topics[m].length; i < j; i++ ) {
                    if ( topics[m][i].token === token ) {
                        topics[m].splice( i, 1 );
                        return token;
                    }
                }
            }
        }
        return this;
    };
}( pubsub ));

var messageLogger = function ( topics, data ) {
    console.log( "Logging: " + topics + ": " + data );
};
//下面我们订阅一个事件
var subscription = pubsub.subscribe( "inbox/newMessage", messageLogger );
//发布事件
pubsub.publish( "inbox/newMessage", "hello world!" );
 
pubsub.publish( "inbox/newMessage", ["test", "a", "b", "c"] );
 

pubsub.publish( "inbox/newMessage", {
  sender: "hello@google.com",
  body: "Hey again!"
});
//取消事件
pubsub.unsubscribe( subscription );
//再次发布事件将不再会执行
pubsub.publish( "inbox/newMessage", "Hello! are you still there?" );



```


## 观察者模式具体实现代码

**我们现在可以通过实现一个观察者模式来进一步扩展我们刚才所学到的东西。这个实现包含一下组件：**

* 1、被观察者：维护一组观察者， 提供用于增加和移除观察者的方法。
* 2、观察者：提供一个更新接口，用于当被观察者状态变化时，得到通知。
* 3、具体的被观察者：状态变化时广播通知给观察者，保持具体的观察者的信息。
* 4、具体的观察者：保持一个指向具体被观察者的引用，实现一个更新接口，用于观察，以便保证自身状态总是和被观察者状态一致的。

**首先，让我们对被观察者可能有的一组依赖其的观察者进行建模：**

```javascript

function ObserverList(){
  this.observerList = [];
}

ObserverList.prototype.add = function( obj ){
  return this.observerList.push( obj );
};

ObserverList.prototype.count = function(){
  return this.observerList.length;
};
 
ObserverList.prototype.get = function( index ){
  if( index > -1 && index < this.observerList.length ){
    return this.observerList[ index ];
  }
};
 
ObserverList.prototype.indexOf = function( obj, startIndex ){
  var i = startIndex;
  while( i < this.observerList.length ){
    if( this.observerList[i] === obj ){
      return i;
    }
    i++;
  }
 
  return -1;
};
 
ObserverList.prototype.removeAt = function( index ){
  this.observerList.splice( index, 1 );
};

```

**接下来，让我们对Subject进行建模，以及在观察者列表中添加，删除或通知观察者的能力。**

```javascript

function Subject(){
  this.observers = new ObserverList();
}
 
Subject.prototype.addObserver = function( observer ){
  this.observers.add( observer );
};
 
Subject.prototype.removeObserver = function( observer ){
  this.observers.removeAt( this.observers.indexOf( observer, 0 ) );
};
 
Subject.prototype.notify = function( context ){
  var observerCount = this.observers.count();
  for(var i=0; i < observerCount; i++){
    this.observers.get(i).update( context );
  }
};

```

然后我们定义一个用于创建新观察者的骨架。update稍后将使用自定义行为覆盖此处的功能。

```javascript

// The Observer
function Observer(){
  this.update = function(){
    // ...
  };
}

```

**在我们使用上述Observer组件的示例应用程序中，我们现在定义：**

* 1、用于向页面添加新的可观察复选框的按钮
* 2、一个控件复选框，它将作为主题，通知其他复选框，应该检查它们
* 3、添加新复选框的容器
**然后，我们定义ConcreteSubject和ConcreteObserver处理程序，以便为页面添加新的观察者并实现更新接口。有关这些组件在我们的示例上下文中执行的操作的内联注释，请参见下文。**

```html

<button id="addNewObserver">Add New Observer checkbox</button>
<input id="mainCheckbox" type="checkbox"/>
<div id="observersContainer"></div>

```


我们在addBtn按钮时创建一个个的checkbox,然后每个checkbox上面都拥有一个update方法，
然后再把这个checkbox对象添加到controlCheckbox对象的订阅数组里，
我们在点击controlCheckbox的时候就执行controlCheckbox的notify方法通知所有的订阅者，把状态传递给每一个订阅者

```javascript

function extend( obj, extension ){
  for ( var key in extension ){
    obj[key] = extension[key];
  }
}
 
 
var controlCheckbox = document.getElementById( "mainCheckbox" );
var addBtn = document.getElementById( "addNewObserver" );
var container = document.getElementById( "observersContainer" );
 
 
extend( controlCheckbox, new Subject() );
 
controlCheckbox.onclick = function(){
  controlCheckbox.notify( controlCheckbox.checked );
};
 
addBtn.onclick = function(){
	var check = document.createElement( "input" );
	check.type = "checkbox";
	extend( check, new Observer() );

	check.update = function( value ){
		this.checked = value;
	};

	controlCheckbox.addObserver( check );
	container.appendChild( check );
}


```

